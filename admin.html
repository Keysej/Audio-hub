<!-- admin.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Admin - SoundDrop</title>
  <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js"></script>
  <link rel="stylesheet" href="style.css">
  <style>
    .admin-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    .login-section {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      margin-bottom: 30px;
    }
    
    .login-form {
      margin-top: 20px;
    }
    
    .login-form input {
      padding: 15px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      margin: 10px;
      width: 200px;
    }
    
    .login-btn {
      background: #ff6b6b;
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      margin: 10px;
      transition: all 0.3s ease;
    }
    
    .login-btn:hover {
      background: #ee5a24;
      transform: translateY(-2px);
    }
    
    .dashboard-section {
      display: none;
      background: white;
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      margin-bottom: 30px;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .stat-card {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      padding: 25px;
      border-radius: 15px;
      text-align: center;
    }
    
    .stat-number {
      font-size: 2.5em;
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    .data-section {
      background: #f8f9fa;
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .section-title {
      color: #2c3e50;
      font-size: 1.5em;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 2px solid #667eea;
    }
    
    .drop-item {
      background: white;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 15px;
      border-left: 4px solid #667eea;
    }
    
    .drop-header {
      display: flex;
      justify-content: between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .drop-title {
      color: #2c3e50;
      font-weight: 600;
      margin: 0;
    }
    
    .drop-meta {
      color: #7f8c8d;
      font-size: 0.9em;
      margin: 5px 0;
    }
    
    .drop-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    .play-btn, .download-btn {
      background: #ff6b6b;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.3s ease;
    }
    
    .play-btn:hover, .download-btn:hover {
      background: #ee5a24;
      transform: translateY(-1px);
    }
    
    .download-btn {
      background: #28a745;
    }
    
    .download-btn:hover {
      background: #218838;
    }
    
    .comments-section {
      background: #e8f4fd;
      padding: 15px;
      border-radius: 8px;
      margin-top: 15px;
    }
    
    .comment {
      background: white;
      padding: 10px;
      margin: 8px 0;
      border-radius: 6px;
      border-left: 3px solid #667eea;
    }
    
    .export-buttons {
      text-align: center;
      margin: 20px 0;
    }
    
    .export-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      margin: 0 10px;
      transition: all 0.3s ease;
    }
    
    .export-btn:hover {
      background: #218838;
      transform: translateY(-2px);
    }
    
    .error-message {
      background: #f8d7da;
      color: #721c24;
      padding: 15px;
      border-radius: 8px;
      margin: 10px 0;
    }
    
    .loading {
      text-align: center;
      padding: 40px;
      color: #7f8c8d;
    }
  </style>
</head>
<body>
  <div class="admin-container">
    <!-- Login Section -->
    <div id="login-section" class="login-section">
        <h1>‚öôÔ∏è SoundDrop Admin</h1>
      <p>Access comprehensive research data and analytics</p>
      <div class="login-form">
        <input type="password" id="admin-password" placeholder="Enter admin password" />
        <br>
        <button class="login-btn" onclick="loginAdmin()">Access Dashboard</button>
      </div>
      <div id="login-error" class="error-message" style="display: none;"></div>
    </div>

    <!-- Dashboard Section -->
    <div id="dashboard-section" class="dashboard-section">
      <h1>üìä Research Dashboard</h1>
      
      <!-- Statistics -->
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-number" id="total-drops">-</div>
          <div>Total Drops</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="active-drops">-</div>
          <div>Active</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="archived-drops">-</div>
          <div>Archived</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="total-comments">-</div>
          <div>Comments</div>
        </div>
      </div>

      <!-- Export Buttons -->
      <div class="export-buttons">
        <button class="export-btn" onclick="exportData('json')">üìÑ Export JSON</button>
        <button class="export-btn" onclick="exportData('csv')">üìä Export CSV</button>
        <button class="export-btn" onclick="refreshData()">üîÑ Refresh Data</button>
        <button class="export-btn" onclick="forceArchive()" style="background: #ff6b6b;">üóÑÔ∏è Test Archive</button>
      </div>

      <!-- Data Display -->
      <div id="data-display">
        <div class="loading">Loading research data...</div>
      </div>
    </div>
  </div>

  <script>
    let adminAuthenticated = false;
    let currentAudio = null;
    let adminPassword = 'research2024';

    function loginAdmin() {
      const password = document.getElementById('admin-password').value;
      const errorDiv = document.getElementById('login-error');
      
      if (password === adminPassword) {
        adminAuthenticated = true;
        document.getElementById('login-section').style.display = 'none';
        document.getElementById('dashboard-section').style.display = 'block';
        loadDashboardData();
        errorDiv.style.display = 'none';
      } else {
        errorDiv.textContent = 'Invalid password. Please try again.';
        errorDiv.style.display = 'block';
      }
    }

    async function loadDashboardData() {
      try {
        let activeData = [];
        
        // First try to load from ADMIN API (7-day data)
        try {
          const activeResponse = await fetch('/api/admin/sound-drops', {
            headers: {
              'Authorization': 'Bearer research2024'
            }
          });
          if (activeResponse.ok) {
            activeData = await activeResponse.json();
            console.log('Loaded data from Admin API (7-day window):', activeData.length, 'drops');
          } else {
            console.log('Admin API not available, trying regular API...');
            // Fallback to regular API
            const fallbackResponse = await fetch('/api/sound-drops');
            if (fallbackResponse.ok) {
              activeData = await fallbackResponse.json();
              console.log('Loaded data from regular API (24-hour window):', activeData.length, 'drops');
            }
          }
        } catch (e) {
          console.log('API not available, will use localStorage');
        }
        
        // If no API data, fall back to localStorage (but with 7-day window for research)
        if (activeData.length === 0) {
          try {
            const stored = localStorage.getItem('soundDropsBackup');
            if (stored) {
              const localData = JSON.parse(stored);
              // For admin dashboard: show data from last 7 days (research needs)
              const now = Date.now();
              const sevenDays = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds
              activeData = localData.filter(drop => (now - drop.timestamp) < sevenDays);
              console.log('Loaded data from localStorage (7-day window):', activeData.length, 'drops');
            }
          } catch (e) {
            console.error('Error reading localStorage:', e);
          }
        }
        
        // Try to load archived data from research endpoint
        let archivedData = [];
        try {
          const exportResponse = await fetch('/api/research/export?format=json&key=research2024');
          if (exportResponse.ok) {
            const exportData = await exportResponse.json();
            if (exportData.data) {
              // Filter for archived data only
              archivedData = exportData.data.filter(drop => drop.data_source === 'archived');
              console.log('Loaded archived data from research API:', archivedData.length, 'drops');
            }
          }
        } catch (e) {
          console.log('Research archive not available:', e);
        }

        // Update statistics
        updateStatistics(activeData, archivedData);
        
        // Display data
        displayData(activeData, archivedData);
        
      } catch (error) {
        console.error('Error loading dashboard data:', error);
        document.getElementById('data-display').innerHTML = 
          `<div class="error-message">Error loading data: ${error.message}</div>`;
      }
    }

    function updateStatistics(activeData, archivedData) {
      const totalComments = activeData.reduce((sum, drop) => sum + (drop.discussions?.length || 0), 0);
      
      document.getElementById('total-drops').textContent = activeData.length + archivedData.length;
      document.getElementById('active-drops').textContent = activeData.length;
      document.getElementById('archived-drops').textContent = archivedData.length;
      document.getElementById('total-comments').textContent = totalComments;
    }

    function displayData(activeData, archivedData) {
      const dataDisplay = document.getElementById('data-display');
      let html = '';

      // Data source indicator
      const dataSource = activeData.length > 0 ? 
        (activeData[0].id ? 'localStorage' : 'API') : 'none';
      
      html += `
        <div style="background: #e8f4fd; padding: 10px; border-radius: 8px; margin-bottom: 20px; font-size: 0.9em;">
          üìä Data Source: ${dataSource === 'localStorage' ? 'üíæ Local Storage (Browser)' : 
                            dataSource === 'API' ? 'üåê API Server' : '‚ùå No Data'}
          <br><small>üóìÔ∏è Showing data from the last 7 days (research view)</small>
          ${dataSource === 'localStorage' ? '<br><small>üí° Data is from your browser storage. API sync may not be working.</small>' : ''}
        </div>
      `;

      // Active Data Section
      if (activeData.length > 0) {
        html += `
          <div class="data-section">
            <h2 class="section-title">üìä Research Data - Last 7 Days (${activeData.length})</h2>
            ${activeData.map(drop => createDropHTML(drop, 'active')).join('')}
          </div>
        `;
      }

      // Archived Data Section (placeholder for now)
      if (archivedData.length > 0) {
        html += `
          <div class="data-section">
            <h2 class="section-title">üì¶ Archived Drops (${archivedData.length})</h2>
            ${archivedData.map(drop => createDropHTML(drop, 'archived')).join('')}
          </div>
        `;
      }

      if (activeData.length === 0 && archivedData.length === 0) {
        html = `
          <div class="data-section">
            <h2 class="section-title">üì≠ No Data Available</h2>
            <p>No research data has been collected yet. Data will appear here as users interact with SoundDrop.</p>
          </div>
        `;
      }

      dataDisplay.innerHTML = html;
    }

    function createDropHTML(drop, type) {
      const timestamp = new Date(drop.timestamp).toLocaleString();
      const commentsHtml = drop.discussions && drop.discussions.length > 0 ? `
        <div class="comments-section">
          <strong>üí¨ Comments (${drop.discussions.length}):</strong>
          ${drop.discussions.map(comment => `
            <div class="comment">
              <strong>${comment.author || 'User'}:</strong> ${comment.text}
              <br><small>${new Date(comment.timestamp).toLocaleString()}</small>
            </div>
          `).join('')}
        </div>
      ` : '';

      return `
        <div class="drop-item">
          <div class="drop-header">
            <h3 class="drop-title">${drop.theme || 'No Theme'}</h3>
            <div class="drop-controls">
              ${drop.audioData ? `<button class="play-btn" onclick="playAudio('${drop.audioData}', this)">‚ñ∂Ô∏è Play</button>` : ''}
              ${drop.audioData ? `<button class="download-btn" onclick="downloadAudio('${drop.audioData}', '${drop.filename || 'recording'}')">üì• Download</button>` : ''}
            </div>
          </div>
          <div class="drop-meta">
            üìÖ ${timestamp} | üéµ ${drop.type || 'Unknown'} | üìÑ ${drop.filename || 'No filename'}
            ${type === 'archived' ? ' | üì¶ Archived' : ''}
          </div>
          ${drop.context ? `<div class="drop-meta">üí≠ ${drop.context}</div>` : ''}
          ${commentsHtml}
        </div>
      `;
    }

    function playAudio(audioData, button) {
      // Stop current audio if playing
      if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
        // Reset all buttons
        document.querySelectorAll('.play-btn').forEach(btn => {
          btn.textContent = '‚ñ∂Ô∏è Play';
        });
      }
      
      // Play new audio
      if (button.textContent === '‚ñ∂Ô∏è Play') {
        currentAudio = new Audio(audioData);
        currentAudio.play();
        button.textContent = '‚è∏Ô∏è Pause';
        
        currentAudio.onended = () => {
          button.textContent = '‚ñ∂Ô∏è Play';
          currentAudio = null;
        };
      }
    }

    async function exportData(format) {
      if (!adminAuthenticated) {
        alert('Please log in first');
        return;
      }
      
      try {
        // Get the same data that's displayed in the dashboard (7-day window)
        let exportData = [];
        
        // First try ADMIN API for 7-day data
        try {
          const apiResponse = await fetch('/api/admin/sound-drops', {
            headers: {
              'Authorization': 'Bearer research2024'
            }
          });
          if (apiResponse.ok) {
            exportData = await apiResponse.json();
            console.log('Export using Admin API (7-day window):', exportData.length, 'drops');
          } else {
            // Fallback to regular API
            const fallbackResponse = await fetch('/api/sound-drops');
            if (fallbackResponse.ok) {
              exportData = await fallbackResponse.json();
              console.log('Export using regular API (24-hour window):', exportData.length, 'drops');
            }
          }
        } catch (e) {
          console.log('API not available for export, using localStorage');
        }
        
        // If no API data, use localStorage with 7-day window (same as dashboard)
        if (exportData.length === 0) {
          try {
            const stored = localStorage.getItem('soundDropsBackup');
            if (stored) {
              const localData = JSON.parse(stored);
              const now = Date.now();
              const sevenDays = 7 * 24 * 60 * 60 * 1000;
              exportData = localData.filter(drop => (now - drop.timestamp) < sevenDays);
            }
          } catch (e) {
            console.error('Error reading localStorage for export:', e);
          }
        }
        
        if (exportData.length === 0) {
          alert('No data available to export');
          return;
        }
        
        const timestamp = new Date().toISOString().split('T')[0];
        
        if (format === 'json') {
          const jsonExport = {
            export_info: {
              timestamp: new Date().toISOString(),
              total_drops: exportData.length,
              date_range: '7 days',
              total_comments: exportData.reduce((sum, drop) => sum + (drop.discussions?.length || 0), 0)
            },
            data: exportData
          };
          downloadJSON(jsonExport, `sounddrop_research_${timestamp}.json`);
        } else if (format === 'csv') {
          downloadCSV(exportData, `sounddrop_research_${timestamp}.csv`);
        }
        
      } catch (error) {
        console.error('Export error:', error);
        alert('Export failed: ' + error.message);
      }
    }

    function downloadJSON(data, filename) {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    function downloadCSV(data, filename) {
      // Flatten data for CSV
      const rows = [];
      const headers = ['id', 'timestamp', 'theme', 'type', 'filename', 'context', 'comments_count'];
      rows.push(headers);

      data.forEach(drop => {
        const row = [
          drop.id || '',
          new Date(drop.timestamp).toISOString(),
          drop.theme || '',
          drop.type || '',
          drop.filename || '',
          drop.context || '',
          drop.discussions?.length || 0
        ];
        rows.push(row);

        // Add comment rows
        if (drop.discussions && drop.discussions.length > 0) {
          drop.discussions.forEach((comment, index) => {
            const commentRow = [
              drop.id || '',
              new Date(drop.timestamp).toISOString(),
              drop.theme || '',
              drop.type || '',
              drop.filename || '',
              `COMMENT_${index + 1}: ${comment.text}`,
              drop.discussions.length
            ];
            rows.push(commentRow);
          });
        }
      });

      const csvContent = rows.map(row => 
        row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(',')
      ).join('\n');

      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    function refreshData() {
      document.getElementById('data-display').innerHTML = '<div class="loading">Refreshing data...</div>';
      loadDashboardData();
    }

    async function forceArchive() {
      if (!adminAuthenticated) {
        alert('Please log in first');
        return;
      }
      
      try {
        const response = await fetch('/api/research/force-archive?key=research2024');
        const result = await response.json();
        
        if (response.ok) {
          alert(`Archive Test Result:\n${result.message}\n\nFound: ${result.total_found || 0} drops\nArchived: ${result.archived || 0} drops`);
          // Refresh the dashboard to show any newly archived data
          refreshData();
        } else {
          alert(`Archive test failed: ${result.error || result.message}`);
        }
      } catch (error) {
        alert(`Archive test error: ${error.message}`);
      }
    }

    // MP3 conversion using LAME encoder (same as main page)
    async function convertAudioToMp3(audioBlob) {
      return new Promise(async (resolve) => {
        try {
          // Check if LAME library is available
          if (typeof lamejs === 'undefined') {
            console.log('LAME library not available, skipping MP3 conversion');
            resolve(null);
            return;
          }
          
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const fileReader = new FileReader();
          
          fileReader.onload = async function() {
            try {
              const arrayBuffer = fileReader.result;
              const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
              
              // Convert to mono for simplicity (MP3 encoding is complex for stereo)
              const channels = audioBuffer.numberOfChannels;
              const sampleRate = audioBuffer.sampleRate;
              const length = audioBuffer.length;
              
              // Get audio data (convert to mono if stereo)
              let samples;
              if (channels === 1) {
                samples = audioBuffer.getChannelData(0);
              } else {
                // Mix stereo to mono
                const left = audioBuffer.getChannelData(0);
                const right = audioBuffer.getChannelData(1);
                samples = new Float32Array(length);
                for (let i = 0; i < length; i++) {
                  samples[i] = (left[i] + right[i]) / 2;
                }
              }
              
              // Convert float samples to 16-bit PCM
              const pcmSamples = new Int16Array(length);
              for (let i = 0; i < length; i++) {
                const sample = Math.max(-1, Math.min(1, samples[i]));
                pcmSamples[i] = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
              }
              
              // Initialize LAME encoder
              const mp3encoder = new lamejs.Mp3Encoder(1, sampleRate, 128); // Mono, sampleRate, 128kbps
              const mp3Data = [];
              
              // Encode in chunks
              const chunkSize = 1152; // LAME chunk size
              for (let i = 0; i < pcmSamples.length; i += chunkSize) {
                const chunk = pcmSamples.subarray(i, i + chunkSize);
                const mp3buf = mp3encoder.encodeBuffer(chunk);
                if (mp3buf.length > 0) {
                  mp3Data.push(mp3buf);
                }
              }
              
              // Finalize encoding
              const mp3buf = mp3encoder.flush();
              if (mp3buf.length > 0) {
                mp3Data.push(mp3buf);
              }
              
              // Create MP3 blob
              const mp3Blob = new Blob(mp3Data, { type: 'audio/mp3' });
              console.log('Successfully encoded MP3:', mp3Blob.size, 'bytes');
              resolve(mp3Blob);
              
            } catch (error) {
              console.log('MP3 encoding failed:', error);
              resolve(null);
            }
          };
          
          fileReader.onerror = () => {
            console.log('FileReader error during MP3 conversion');
            resolve(null);
          };
          
          fileReader.readAsArrayBuffer(audioBlob);
          
        } catch (error) {
          console.log('MP3 conversion setup failed:', error);
          resolve(null);
        }
      });
    }

    // Convert AudioBuffer to WAV Blob (fallback)
    function audioBufferToWav(buffer) {
      const length = buffer.length;
      const numberOfChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const arrayBuffer = new ArrayBuffer(44 + length * numberOfChannels * 2);
      const view = new DataView(arrayBuffer);
      
      // WAV header
      const writeString = (offset, string) => {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      };
      
      writeString(0, 'RIFF');
      view.setUint32(4, 36 + length * numberOfChannels * 2, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numberOfChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * numberOfChannels * 2, true);
      view.setUint16(32, numberOfChannels * 2, true);
      view.setUint16(34, 16, true);
      writeString(36, 'data');
      view.setUint32(40, length * numberOfChannels * 2, true);
      
      // Convert audio data
      let offset = 44;
      for (let i = 0; i < length; i++) {
        for (let channel = 0; channel < numberOfChannels; channel++) {
          const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
          offset += 2;
        }
      }
      
      return new Blob([arrayBuffer], { type: 'audio/wav' });
    }

    // Convert audio to WAV format (fallback)
    async function convertAudioToWav(audioBlob) {
      return new Promise((resolve) => {
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const fileReader = new FileReader();
          
          fileReader.onload = async function() {
            try {
              const arrayBuffer = fileReader.result;
              const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
              
              // Convert to WAV
              const wavBlob = audioBufferToWav(audioBuffer);
              resolve(wavBlob);
            } catch (error) {
              console.log('Audio conversion failed, using original:', error);
              resolve(audioBlob); // Fallback to original
            }
          };
          
          fileReader.onerror = () => {
            console.log('FileReader error, using original audio');
            resolve(audioBlob); // Fallback to original
          };
          
          fileReader.readAsArrayBuffer(audioBlob);
        } catch (error) {
          console.log('Conversion not supported, using original:', error);
          resolve(audioBlob); // Fallback to original
        }
      });
    }

    // Enhanced download function with MP3 conversion (same as main page)
    async function downloadAudio(audioData, filename) {
      if (!audioData) {
        alert('No audio data available for download');
        return;
      }
      
      try {
        const mimeMatch = audioData.match(/data:([^;]+);base64,/);
        let fileExtension = '.mp3'; // Default to MP3 for best compatibility
        let downloadUrl = audioData;
        
        if (mimeMatch) {
          const mimeType = mimeMatch[1];
          console.log('Original audio MIME type:', mimeType);
          
          // Always try to convert to MP3 for maximum desktop compatibility
          if (typeof AudioContext !== 'undefined') {
            try {
              console.log('Converting audio to MP3 for maximum desktop compatibility...');
              
              // Convert data URL back to blob
              const response = await fetch(audioData);
              const originalBlob = await response.blob();
              
              // Convert to MP3 using LAME encoder
              const mp3Blob = await convertAudioToMp3(originalBlob);
              if (mp3Blob) {
                downloadUrl = URL.createObjectURL(mp3Blob);
                fileExtension = '.mp3';
                console.log('Successfully converted to MP3 format');
              } else {
                // Fallback to WAV
                const wavBlob = await convertAudioToWav(originalBlob);
                downloadUrl = URL.createObjectURL(wavBlob);
                fileExtension = '.wav';
                console.log('Converted to WAV format as fallback');
              }
            } catch (conversionError) {
              console.log('Conversion failed, using original format:', conversionError);
              // Determine original file extension
              if (mimeType.includes('mp4')) fileExtension = '.mp4';
              else if (mimeType.includes('webm')) fileExtension = '.webm';
              else if (mimeType.includes('wav')) fileExtension = '.wav';
              else if (mimeType.includes('ogg')) fileExtension = '.ogg';
            }
          }
        }
        
        // Create download link
        const a = document.createElement('a');
        a.href = downloadUrl;
        a.download = `${filename || 'recording'}${fileExtension}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        // Clean up object URL if we created one
        if (downloadUrl !== audioData) {
          setTimeout(() => URL.revokeObjectURL(downloadUrl), 1000);
        }
        
        console.log(`Downloaded audio as: ${filename}${fileExtension}`);
      } catch (error) {
        console.error('Download error:', error);
        alert('Failed to download audio file');
      }
    }

    // Handle Enter key in password field
    document.addEventListener('DOMContentLoaded', function() {
      document.getElementById('admin-password').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          loginAdmin();
        }
      });
    });
  </script>
</body>
</html>
